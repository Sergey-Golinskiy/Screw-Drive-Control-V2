# Screw-Drive Control — TouchDesk (PyQt5) + Web UI + Cycle Script

Полная инструкция по установке «с нуля» и работе трёх компонентов на Raspberry Pi c сенсорным экраном 1920×1080:

- `cycle_onefile.py` — внешний сценарий цикла (управление реле/датчиками GPIO, логика цикла, триггер).
- `web_ui.py` — локальный REST API и простая веб-панель (старт/стоп внешнего процесса, ручное управление).
- `touchdesk.py` — полноэкранный тач-интерфейс (PyQt5) с вкладками **WORK / START / SERVICE**, цветной «рамкой-индикатором», скрытым курсором и экранной клавиатурой.

> Все пути и команды ниже даны для пользователя `smartgrow`. Если у тебя другой пользователь — замени имя в путях и в unit-файлах.

---

## 1) Архитектура и взаимодействие

### Компоненты

- **Внешний цикл** (`cycle_onefile.py`)
  - Работает с GPIO (реле/датчики) по BCM-нумерации.
  - Имеет **локальный TCP-триггер** на `127.0.0.1:8765`: если туда отправить `START\n`, выполняется один цикл.
  - Во время активного цикла выставляет флаг занятости (например, через файл-флаг `BUSY`), по завершении — снимает.

- **Web API + панель** (`web_ui.py`)
  - Поднимает локальный HTTP-сервер на `0.0.0.0:8000`.
  - Эндпоинты:
    - `GET /api/status` — текущий статус: `relays`, `sensors`, `external_running` и т. п.
    - `POST /api/ext/start` — запускает `cycle_onefile.py` как внешний процесс (владение GPIO отдаётся внешнему процессу).
    - `POST /api/ext/stop` — останавливает внешний процесс и возвращает управление GPIO в API.
    - `POST /api/relay` — **ручное** управление реле (`on/off/pulse`) — **блокируется**, если внешний процесс запущен.
    - (Опционально) `POST /api/trigger/start` — отправляет `START\n` на `127.0.0.1:8765` (эмуляция педали).
  - Веб-страница даёт минимальные кнопки: старт/стоп внешнего процесса, отправка `START`.

- **TouchDesk** (`touchdesk.py`)
  - Полноэкранное PyQt5-приложение. Автоматически выбирает `eglfs`, если нет `$DISPLAY/$WAYLAND_DISPLAY` (то есть может работать без рабочего стола, прямо на фреймбуфере).
  - Вкладки:
    - **WORK** — IP, большая кнопка эмуляции `START`, статус/подсветка.
    - **START** — большие кнопки **START program** / **STOP program** (старт/стоп внешнего процесса). У `STOP` отдельный «красный» стиль.
    - **SERVICE** — паролем защищённый доступ к статусам концевиков и сенсоров, управлению реле (ON/OFF/PULSE), доступ к Arduino через Serial (не закрывающаяся сессия, лог, отправка команд). Экранная клавиатура появляется при фокусе в поле ввода.
  - «Рамка-индикатор» по периметру экрана:
    - **зелёная** — цикл выполняется;
    - **жёлтая** — ожидание;
    - **красная** — обнаружен аварийный сигнал (любой сенсор с именем, содержащим `alarm/emerg/fault/error/e_stop` и значением `True`).
  - `API_BASE` по умолчанию `http://127.0.0.1:8000/api`, можно переопределить переменной окружения.

---

## 2) Аппаратные подключения

- Конкретные BCM-пины для реле/датчиков заданы в верхней части `cycle_onefile.py`.
- Реле обычно **активны уровнем LOW** (`RELAY_ACTIVE_LOW=True`), датчики читаются уровнем `True/False`.

---

## 3) Установка на чистую Raspberry Pi OS (Bullseye/Bookworm)

### 3.1. Системные пакеты

```bash
sudo apt update
sudo apt install -y \
  python3 python3-pip python3-venv \
  python3-flask python3-requests python3-serial python3-rpi.gpio \
  python3-pyqt5 qt5-qpa-platform-plugins \
  fonts-dejavu-core libxkbcommon-x11-0 libxcb-cursor0
```

### 3.2. Права пользователя

```bash
sudo usermod -aG gpio,dialout $USER
newgrp gpio
```

### 3.3. Каталог проекта

```bash
mkdir -p ~/Screw-Drive-Control/Base_Logic_Web
cd ~/Screw-Drive-Control/Base_Logic_Web
# Скопируй сюда: cycle_onefile.py, web_ui.py, touchdesk.py, (опционально logo.png)
```

### 3.4. (Опционально) Виртуальное окружение

```bash
python3 -m venv --system-site-packages ~/touchdesk-venv
source ~/touchdesk-venv/bin/activate
pip install --upgrade pip
```

---

## 4) Ручной запуск

### 4.1. Запуск Web API

```bash
cd ~/Screw-Drive-Control/Base_Logic_Web
python3 web_ui.py
# Открой http://<IP_RPi>:8000 в браузере
```

### 4.2. Запуск TouchDesk

```bash
cd ~/Screw-Drive-Control/Base_Logic_Web
python3 touchdesk.py
```

---

## 5) Автозапуск через systemd

### 5.1. Web API — `/etc/systemd/system/web-ui@.service`

```ini
[Unit]
Description=RPi IO Web API (Flask) for %i
After=network-online.target
Wants=network-online.target

[Service]
User=%i
WorkingDirectory=/home/%i/Screw-Drive-Control/Base_Logic_Web
ExecStart=/usr/bin/python3 /home/%i/Screw-Drive-Control/Base_Logic_Web/web_ui.py
Restart=always
Environment=PYTHONUNBUFFERED=1

[Install]
WantedBy=multi-user.target
```

### 5.2. TouchDesk — `/etc/systemd/system/touchdesk.service`

```ini
[Unit]
Description=TouchDesk (PyQt5) fullscreen UI
After=SD.service web-ui@smartgrow.service network-online.target
Wants=web-ui@smartgrow.service

[Service]
User=smartgrow
WorkingDirectory=/home/smartgrow/Screw-Drive-Control/Base_Logic_Web
Environment=QT_QPA_PLATFORM=eglfs
Environment=API_BASE=http://127.0.0.1:8000/api
ExecStart=/usr/bin/python3 /home/smartgrow/Screw-Drive-Control/Base_Logic_Web/touchdesk.py
Restart=always
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
```

---

## 6) Диагностика

```bash
journalctl -u web-ui@smartgrow.service -f
journalctl -u touchdesk.service -f
```

---

## 7) Структура проекта

```
Screw-Drive-Control/
└─ Base_Logic_Web/
   ├─ cycle_onefile.py
   ├─ web_ui.py
   ├─ touchdesk.py
   └─ logo.png
```

## 8) Что и как работает
- **cycle_onefile.py** — управляет реальным циклом закрутки: подача винта, работа цилиндров, проверка датчиков. Использует GPIO и локальный сокет.
- **web_ui.py** — HTTP API для интеграции и простая веб-панель. Реализовано на Flask. Позволяет запускать/останавливать цикл, проверять статусы, тестировать реле.
- **touchdesk.py** — полноценный интерфейс для сенсорного экрана. Реализовано на PyQt5. Управляет состояниями, отображает статусы, обеспечивает удобную работу оператору (большие кнопки, цветовые индикаторы, клавиатура на экране).

---

# Автоматизированный цикл управления отвёрточной станцией - cycle_onefile.py

## Обзор

`cycle_onefile.py` предназначен для управления станцией автоматической завёртки винтов на базе **Raspberry Pi** и внешнего Arduino‑контроллера.  
Он объединяет управление реле (цилиндры, подача винтов, режимы драйвера отвёртки), обработку датчиков (герконы, индуктивные, педаль запуска), а также управление координатным столом через G‑код по Serial.

Сценарий реализует полный цикл:  
1. Подъём/опускание цилиндров.  
2. Подача винта и контроль его наличия.  
3. Завёртка винта до заданного момента.  
4. Поднятие инструмента и переход к следующей точке.

---

## Используемые технологии и библиотеки

- **Python 3**
- **RPi.GPIO** — работа с GPIO Raspberry Pi (реле и датчики).  
- **pySerial** (`serial`) — обмен по UART с Arduino‑контроллером (протокол G‑код).  
- **socket** — локальный TCP‑сервер для удалённого старта цикла (например, от UI).  
- **threading** — фоновая обработка событий и опрос датчиков.  
- **pathlib / os** — файловый флаг занятости цикла.  
- **datetime** — отметки времени в логах.

---

## Аппаратные компоненты

### Реле (RELAY_PINS)
- **R01_PIT** — импульс подачи винтов.  
- **R02_C1_UP / R03_C1_DOWN** — управление основным цилиндром.  
- **R04_C2** — цилиндр отвёртки (опускание/поднятие).  
- **R05_DI4_FREE** — свободный ход отвёртки (free‑run).  
- **R06_DI1_POT** — режим «по моменту» (torque mode).  
- **R07_DI5_TSK0** — выбор задачи (импульс 700 мс).  
- **R08** — запасной канал.

### Датчики (SENSOR_PINS)
- Герконы: положение цилиндров (верх/низ).  
- Индуктивный **IND_SCRW** — факт прохождения винта.  
- **DO2_OK** — сигнал от драйвера: момент достигнут, завёртка успешна.  
- **PED_START** — педаль запуска цикла.

---

## Основные классы и функции

### IOController
- Инициализирует GPIO (реле и датчики).  
- Управляет реле (`set_relay`, `pulse`).  
- Считывает состояние датчиков (`sensor_state`).  
- Поддерживает edge‑детект или fallback‑polling.

### Serial‑блок
- `open_serial()` — открытие порта.  
- `wait_ready()` — ожидание строки `ok READY` от Arduino.  
- `send_cmd()` — отправка G‑кода и ожидание ответа.  
- `move_xy()` — перемещение по координатам.

### StartTrigger
- TCP‑сервер на `127.0.0.1:8765`.  
- Позволяет внешнему UI послать команду `START` для запуска цикла.  
- Внутри выставляет событие `event`.

### Хелперы
- `wait_sensor()` — ожидание состояния датчика с таймаутом.  
- `wait_new_press()` — корректное ожидание нового нажатия педали.  
- `feed_until_detect()` — повторная подача винта до подтверждения датчиком.  
- `torque_sequence()` — алгоритм закручивания по моменту с free‑run импульсом.  
- `torque_fallback()` — аварийный выход, если момент не достигнут.

---

## Логика работы (main)

1. Инициализация GPIO и запуска TCP‑триггера.  
2. Подключение к Arduino по Serial, ожидание `ok READY`.  
3. Хоуминг стола (`G28`).  
4. Проверка положения цилиндров (C1, C2).  
5. Вход в основной цикл:  
   - Ожидание педали **PED_START** или команды **START** по TCP.  
   - Перемещение стола в координаты трёх точек (`POINTS`).  
   - На каждой точке:  
     - Подача винта.  
     - Контроль прохождения индуктивным датчиком.  
     - Запуск torque‑последовательности.  
     - Free‑run импульс.  
   - Возврат в безопасную точку.  
   - Переход к следующему циклу.

6. В любой момент: `Ctrl+C` завершает процесс, освобождаются GPIO, закрывается Serial.

---

## Управление и интеграция

- Запуск через педаль (**PED_START**) или TCP‑команду `START`.  
- Статус занятости пишется в файл `/tmp/screw_cycle_busy`.  
- Все действия логируются с временными метками.  

---

## Установка и запуск

1. Установить Python 3, Raspberry Pi OS.  
2. Установить зависимости:
   ```bash
   sudo apt install python3-rpi.gpio python3-serial
   ```
3. Скопировать `cycle_onefile.py` на Raspberry Pi.  
4. Подключить Arduino к `/dev/ttyACM0`, прошивка должна отвечать `ok READY`.  
5. Подключить релейный модуль и датчики по схеме (BCM‑пины указаны в коде).  
6. Запустить:
   ```bash
   python3 cycle_onefile.py
   ```
7. Для внешнего запуска цикла: отправить `START` на `127.0.0.1:8765`.

---

## Примечания

- Логика рассчитана на **LOW‑trigger реле** (активный уровень — LOW).  
- Для герконов используется `GPIO.PUD_UP` (замкнуты на GND).  
- Все таймауты, координаты и времена импульсов можно подстраивать в начале файла.  
- При обрыве датчика или проблеме с моментом — алгоритм делает безопасный выход.

---

# Web UI для управления станцией завёртки винтов - web_ui.p

## Обзор

`web_ui.py` реализует **веб-интерфейс управления Raspberry Pi GPIO и внешним скриптом `cycle_onefile.py`**.  
Он предоставляет API (REST) и графический UI (HTML+JS), позволяющий:

- Просматривать состояние реле и датчиков.  
- Включать/выключать/импульсно управлять реле.  
- Запускать и останавливать основной цикл (`cycle_onefile.py`) как отдельный процесс.  
- Отправлять команду `START` в запущенный цикл.  

Таким образом, `web_ui.py` выполняет роль **панели управления и мониторинга**, которая может работать автономно или как управляющий слой над внешним скриптом.

---

## Используемые технологии и библиотеки

- **Python 3**
- **Flask** — веб-сервер и REST API.  
- **threading** — синхронизация доступа к GPIO.  
- **subprocess** — запуск/остановка внешнего скрипта.  
- **signal** — корректное завершение внешнего процесса.  
- **socket** — передача команды `START` в цикл.  
- **time, os, sys** — служебные операции.  
- **cycle_onefile.IOController** — класс из соседнего файла для работы с GPIO.

---

## Основные компоненты

### Инициализация
- Создаётся объект Flask (`app`).  
- Инициализируется `IOController` (если внешний процесс не запущен).  
- Переменные:
  - `ext_proc` — объект процесса `cycle_onefile.py`.  
  - `BUSY_FLAG = /tmp/screw_cycle_busy` — флаг занятости цикла.  
  - `io_lock` — синхронизация доступа к GPIO.

### Управление GPIO
- `_sensor_state(name)` — возвращает состояние датчика.  
- `_set_relay(name, on)` — включает/выключает реле.  
- `_pulse(name, ms)` — подаёт импульс.  
- Все функции блокируются `with_io_lock` для безопасного доступа.

### Управление внешним процессом
- `ext_start()` — освобождает GPIO, запускает `cycle_onefile.py` через `subprocess.Popen`.  
- `ext_stop()` — останавливает внешний процесс (SIGINT → wait → kill при необходимости).  
- `ext_is_running()` — проверка, жив ли процесс.

### Статус
- `build_status()` возвращает JSON с:
  - временем,  
  - состояниями реле и датчиков,  
  - списками имён,  
  - статусом внешнего процесса,  
  - состоянием busy-флага.

### API эндпоинты
- **GET `/api/status`** — получить текущий статус.  
- **POST `/api/relay`** — управление реле (`on`, `off`, `pulse`).  
- **POST `/api/ext/start`** — запуск `cycle_onefile.py`.  
- **POST `/api/ext/stop`** — остановка `cycle_onefile.py`.  
- **POST `/api/trigger/start`** — отправить команду `START` во внешний цикл.  

### Веб-интерфейс
- Встроенный HTML (строка `INDEX_HTML`) содержит UI на чистом JS.  
- Интерфейс позволяет:
  - управлять запуском/остановкой внешнего цикла,  
  - наблюдать состояние датчиков и реле,  
  - вручную управлять реле (если внешний процесс не запущен).  
- JS каждые 1000 мс опрашивает `/api/status` и обновляет DOM.  

### Запуск
- Функция `main()` запускает Flask-сервер на `0.0.0.0:8000`.  
- При завершении (Ctrl+C) GPIO корректно освобождаются.

---

## Логика работы UI

1. При открытии браузера по адресу Raspberry Pi: `http://<ip>:8000/` загружается панель.  
2. Панель каждые 1 секунду опрашивает API `/api/status`.  
3. Если внешний процесс (`cycle_onefile.py`) работает:
   - GPIO недоступны из UI (реле и датчики не трогаются).  
   - Кнопки управления реле блокируются.  
   - Доступна только кнопка `Send START`.  
4. Если внешний процесс остановлен:
   - Можно вручную включать/выключать реле.  
   - Можно видеть текущее состояние датчиков.  

---

## Установка и запуск

1. Установить зависимости:
   ```bash
   sudo apt install python3-flask python3-rpi.gpio python3-serial
   ```
2. Убедиться, что `cycle_onefile.py` лежит рядом с `web_ui.py`.  
3. Запустить веб-сервер:
   ```bash
   python3 web_ui.py
   ```
4. Открыть в браузере:  
   ```
   http://<ip-адрес-RaspberryPi>:8000/
   ```

---

## Интеграция с циклом

- При нажатии **Start external**:  
  Запускается `cycle_onefile.py`, который полностью берёт под контроль GPIO.  
- При нажатии **Send START**:  
  В `cycle_onefile.py` отправляется команда через TCP (`127.0.0.1:8765`).  
- При нажатии **Stop external**:  
  `cycle_onefile.py` получает SIGINT и корректно завершается. GPIO возвращаются UI.

---

## Примечания

- Веб-интерфейс — лёгкий, не использует сторонние фронтенд-фреймворки.  
- Всё управление завязано на локальном REST API и TCP-сокете.  
- Busy-флаг `/tmp/screw_cycle_busy` используется для синхронизации статуса с внешним процессом.  
- При аварийном завершении процесса UI восстановит GPIO при следующем старте.  

---

# TouchDesk (PyQt5 UI для сенсорного экрана) - touchdesk.py

## Обзор

`touchdesk.py` реализует **графический интерфейс оператора для сенсорного экрана на Raspberry Pi**, используя **PyQt5**.  
Приложение выступает как полноценная панель управления станцией завёртки винтов:

- Управление запуском/остановкой программы (`cycle_onefile.py`) через API.  
- Эмуляция педали запуска и отправка команд `START`.  
- Отображение статуса датчиков, реле и текущего состояния системы.  
- Сервисный режим: ручное управление реле, работа с Serial (Arduino), логирование.  
- Экранная клавиатура и диалог ввода пароля для защищённых функций.  

---

## Используемые технологии и библиотеки

- **Python 3**
- **PyQt5** — GUI (QMainWindow, QTabWidget, QLayouts, QPushButton и др.).  
- **requests** — HTTP-запросы к API (`web_ui.py`).  
- **socket** — локальные TCP-подключения (отправка `START`).  
- **RPi.GPIO** — работа с GPIO (эмуляция педали).  
- **pyserial** — работа с Arduino через Serial.  
- **re, time, os, sys** — служебные библиотеки.  

---

## Основные компоненты

### Конфигурация
- `API_BASE = http://127.0.0.1:8000/api` — базовый адрес REST API.  
- `PEDAL_GPIO_PIN = 18` — BCM-пин для аппаратной педали.  
- `PEDAL_ACTIVE_LOW = True` — активный уровень педали.  
- `POLL_MS = 1000` — период опроса API.  
- `BORDER_W = 10` — толщина цветной рамки статуса.

### Вспомогательные функции
- `send_start_trigger()` и `send_start_trigger_with_retry()` — отправка команды `START` по TCP.  
- `req_get`, `req_post` — запросы к API.  
- `gpio_pedal_init`, `gpio_pedal_pulse`, `gpio_cleanup` — работа с аппаратной педалью.

### Классы

#### ApiClient
Обёртка над REST API (`/api/status`, `/api/ext/start`, `/api/ext/stop`, `/api/relay`).  
Поддерживает:  
- управление реле,  
- запуск/остановку программы,  
- эмуляцию педали,  
- остановку скрипта.

#### SerialReader (QThread)
Поток для чтения/записи данных в Serial‑порт (Arduino).  
- Автоматическое чтение строк и отправка сигналов в UI.  
- Поддержка открытия/закрытия порта и передачи команд.

#### WorkTab
Вкладка **WORK**:  
- Большие кнопки для эмуляции педали и остановки скрипта.  
- Статус запуска программы.  
- Подсветка кнопок в зависимости от состояния (`busy`, `running`).

#### ServiceTab
Вкладка **SERVICE**:  
- Таблицы датчиков и реле с возможностью ручного управления.  
- Блок управления Serial (порт, скорость, лог, отправка команд).  
- Экранная клавиатура для ввода текста.  

#### StartTab
Вкладка **START**:  
- Большие кнопки запуска/остановки программы.  
- Отображение текущего статуса.  

#### VirtualKeyboard
Экранная клавиатура для тачскрина. Поддерживает ввод символов, пробел, backspace, clear, enter.  

#### PasswordDialog
Окно ввода пароля для доступа к сервисной вкладке. Пароль по умолчанию: `1234`.  

#### MainWindow
Главное окно приложения.  
- Включает три вкладки: **WORK**, **START**, **SERVICE**.  
- Окрашивает рамку по состоянию: зелёная (ok), жёлтая (idle), красная (alarm).  
- Логотип в правом верхнем углу.  
- Полноэкранный режим для удобной работы на тачскрине.  
- Опрос API каждые 1000 мс и обновление интерфейса.  

---

## Логика работы

1. При запуске приложение показывает вкладку **START**.  
2. После запуска внешнего скрипта (`cycle_onefile.py`) вкладки **START** и **SERVICE** блокируются.  
3. Основная работа идёт во вкладке **WORK** (педаль или командный запуск цикла).  
4. Вкладка **SERVICE** доступна только после ввода пароля (по умолчанию — `1234`).  
5. При срабатывании датчиков аварий/ошибок рамка окрашивается в красный цвет.  
6. Статус цикла подсвечивает кнопки (`busy` → зелёная подсветка, `idle` → жёлтая).  

---

## Установка и запуск

1. Установить зависимости:
   ```bash
   sudo apt install python3-pyqt5 python3-requests python3-rpi.gpio python3-serial
   ```
2. Скопировать `touchdesk.py` на Raspberry Pi.  
3. Убедиться, что работает веб‑API (`web_ui.py`).  
4. Запустить:
   ```bash
   python3 touchdesk.py
   ```
5. Интерфейс откроется на сенсорном экране в полноэкранном режиме.  

---

## Примечания

- Цвет рамки:  
  - **зелёный** — цикл активен,  
  - **жёлтый** — система в режиме ожидания,  
  - **красный** — авария/ошибка.  
- Экранная клавиатура встроена, не требует внешнего ПО.  
- Serial‑панель позволяет напрямую управлять Arduino для отладки.  
- Дизайн выполнен под использование пальцами (крупные кнопки, поля).  

---
